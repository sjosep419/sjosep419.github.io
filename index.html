<!DOCTYPE html>
<html>
    <head>
        <script src="//d3js.org/d3.v3.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-array@3"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-color@3"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-format@3"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-interpolate@3"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-time@3"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-time-format@4"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-scale@4"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.2.2/d3.min.js"></script>
        <script src ="https://d3js.org/d3.v4.min.js"></script>
        <script type = "text/javascript" src ="https://d3js.org/d3-axis.v1.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/d3-selection@3"></script>
        <script src="data2018.js"></script>
        <script src="singleLinked17.js" defer></script>

    
    </head>
    <body>
        <h1>Single-Linked View</h1>
        <div id="chart"></div>
        <p>Take plz work #26 :(</p>

        <script>
            function LineChart(data2018, {
                x = ([x]) => x, // given d in data, returns the (temporal) x-value
                y = ([, y]) => y, // given d in data, returns the (quantitative) y-value
                z = () => 1, // given d in data, returns the (categorical) z-value
                title, // given d in data, returns the title text
                defined, // for gaps in data
                curve = d3.curveLinear, // method of interpolation between points
                marginTop = 20, // top margin, in pixels
                marginRight = 30, // right margin, in pixels
                marginBottom = 30, // bottom margin, in pixels
                marginLeft = 40, // left margin, in pixels
                width = 640, // outer width, in pixels
                height = 400, // outer height, in pixels
                xType = d3.scaleUtc, // type of x-scale
                xDomain, // [xmin, xmax]
                xRange = [marginLeft, width - marginRight], // [left, right]
                yType = d3.scaleLinear, // type of y-scale
                yDomain, // [ymin, ymax]
                yRange = [height - marginBottom, marginTop], // [bottom, top]
                yFormat, // a format specifier string for the y-axis
                yLabel, // a label for the y-axis
                zDomain, // array of z-values
                color = "currentColor", // stroke color of line, as a constant or a function of *z*
                strokeLinecap, // stroke line cap of line
                strokeLinejoin, // stroke line join of line
                strokeWidth = 1.5, // stroke width of line
                strokeOpacity, // stroke opacity of line
                mixBlendMode = "multiply", // blend mode of lines
                voronoi // show a Voronoi overlay? (for debugging)
            } = {}) {
                // Compute values.
                const X = d3.map(data2018, x);
                const Y = d3.map(data2018, y);
                const Z = d3.map(data2018, z);
                const O = d3.map(data2018, d => d);
                if (defined === undefined) defined = (d, i) => !isNaN(X[i]) && !isNaN(Y[i]);
                const D = d3.map(data, defined);
            
                // Compute default domains, and unique the z-domain.
                xDomain = d3.extent(Object.keys(X));
                yDomain = [0, d3.max(Object.keys(Y), d => typeof d === "string" ? +d : d)];
                zDomain = Z;
                zDomain = new d3.InternSet(Object.keys(zDomain));
            
                // Omit any data not present in the z-domain.
                const I = d3.range(X.length).filter(i => zDomain.has(Z[i]));
            
                // Construct scales and axes.
                const xScale = xType(xDomain, xRange);
                const yScale = yType(yDomain, yRange);
                const xAxis = d3.axisBottom(xScale).ticks(width / 80).tickSizeOuter(0);
                const yAxis = d3.axisLeft(yScale).ticks(height / 60, yFormat);
            
                // Compute titles.
                const T = title === undefined ? Z : title === null ? null : d3.map(data, title);
            
                // Construct a line generator.
                const line = d3.line()
                    .defined(i => D[i])
                    .curve(curve)
                    .x(i => xScale(X[i]))
                    .y(i => yScale(Y[i]));
            
                // Create a svg with dimension constrains.
                const svg = d3.select("chart")
                    d3.append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("viewBox", [0, 0, width, height])
                    .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
                    .style("-webkit-tap-highlight-color", "transparent")
                    .on("pointerenter", pointerentered)
                    .on("pointermove", pointermoved)
                    .on("pointerleave", pointerleft)
                    .on("touchstart", event => event.preventDefault());
            
                // // An optional Voronoi display.
                // if (voronoi) svg.append("path")
                //     .attr("fill", "none")
                //     .attr("stroke", "#ccc")
                //     .attr("d", d3.Delaunay
                //       .from(I, i => xScale(X[i]), i => yScale(Y[i]))
                //       .voronoi([0, 0, width, height])
                //       .render());
            
                svg.append("g")
                    .attr("transform", `translate(0,${height - marginBottom})`)
                    .call(xAxis);
            
                svg.append("g")
                    .attr("transform", `translate(${marginLeft},0)`)
                    .call(yAxis)
                    .call(g => g.select(".domain").remove())
                    // .call(voronoi ? () => {} : g => g.selectAll(".tick line").clone()
                    //     .attr("x2", width - marginLeft - marginRight)
                    //     .attr("stroke-opacity", 0.1))
                    .call(g => g.append("text")
                        .attr("x", -marginLeft)
                        .attr("y", 30)
                        .attr("fill", "black")
                        .attr("text-anchor", "start")
                        .style("font-size", "12px")
                        .text(yLabel));
                
                svg.append("text")
                .attr("transform", "translate(" + (width/2) + " ," + (height) + ")")
                .style("text-anchor", "middle")
                .style("font-size", "14px")
                .text("Month");
                
                const path = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", typeof color === "string" ? color : null)
                    // .attr("stroke-linecap", strokeLinecap)
                    // .attr("stroke-linejoin", strokeLinejoin)
                    .attr("stroke-width", strokeWidth)
                    // .attr("stroke-opacity", strokeOpacity)
                    .selectAll("path")
                    .data(d3.group(I, i => Z[i]))
                    .enter().append("path")
                    .style("mix-blend-mode", mixBlendMode)
                    .attr("stroke", typeof color === "function" ? ([z]) => color(z) : null)
                    .attr("d", ([, I]) => line(I));
            
                const dot = svg.append("g")
                    .attr("display", "none");
            
                dot.append("circle")
                    .attr("r", 2.5);
            
                dot.append("text")
                    .attr("font-family", "sans-serif")
                    .attr("font-size", 10)
                    .attr("text-anchor", "middle")
                    .attr("y", -8);
            
                // Function to keep track of the the mouse pointer on the graph
                function pointermoved(event) {
                const [xm, ym] = d3.pointer(event);
                const i = d3.least(I, i => Math.hypot(xScale(X[i]) - xm, yScale(Y[i]) - ym)); // closest point
                path.style("stroke", ([z]) => Z[i] === z ? null : "#ddd").filter(([z]) => Z[i] === z).raise();
                dot.attr("transform", `translate(${xScale(X[i])},${yScale(Y[i])})`);
                if (T) dot.select("text").text(T[i]);
                svg.property("value", O[i]).dispatch("input", {bubbles: true});
                }
            
                function pointerentered() {
                path.style("mix-blend-mode", null).style("stroke", "#ddd");
                dot.attr("display", null);
                }
            
                function pointerleft() {
                path.style("mix-blend-mode", mixBlendMode).style("stroke", null);
                dot.attr("display", "none");
                svg.node().value = null;
                svg.dispatch("input", {bubbles: true});
                }
                
                // return Object.assign(svg.node(), {value: null});
            }
        </script>
    </body>
</html>

 
 <!-- <!DOCTYPE html>
 <meta charset="utf-8">
 
 Load d3.js
 <script src="https://d3js.org/d3.v4.js"></script>
 
 Create a div where the graph will take place
 <div id="my_dataviz"></div>

 <script>

    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 30, left: 40},
        width = 460 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;
    
    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
      .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform",
              "translate(" + margin.left + "," + margin.top + ")");
    
    // get the data
    d3.csv("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/1_OneNum.csv", function(data) {
    
      // X axis: scale and draw:
      var x = d3.scaleLinear()
          .domain([0, 1000])     // can use this instead of 1000 to have the max of data: d3.max(data, function(d) { return +d.price })
          .range([0, width]);
      svg.append("g")
          .attr("transform", "translate(0," + height + ")")
          .call(d3.axisBottom(x));
    
      // set the parameters for the histogram
      var histogram = d3.histogram()
          .value(function(d) { return d.price; })   // I need to give the vector of value
          .domain(x.domain())  // then the domain of the graphic
          .thresholds(x.ticks(70)); // then the numbers of bins
    
      // And apply this function to data to get the bins
      var bins = histogram(data);
    
      // Y axis: scale and draw:
      var y = d3.scaleLinear()
          .range([height, 0]);
          y.domain([0, d3.max(bins, function(d) { return d.length; })]);   // d3.hist has to be called before the Y axis obviously
      svg.append("g")
          .call(d3.axisLeft(y));
    
      // append the bar rectangles to the svg element
      svg.selectAll("rect")
          .data(bins)
          .enter()
          .append("rect")
            .attr("x", 1)
            .attr("transform", function(d) { return "translate(" + x(d.x0) + "," + y(d.length) + ")"; })
            .attr("width", function(d) { return x(d.x1) - x(d.x0) -1 ; })
            .attr("height", function(d) { return height - y(d.length); })
            .style("fill", "#69b3a2")
    
    });
    </script> -->